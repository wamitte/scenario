<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>决战：沈奎 VS 狂将</title>
    <style>
        body {
            margin: 0;
            background-color: #222;
            color: white;
            font-family: 'Microsoft YaHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }

        #gameCanvas {
            background-color: #333;
            border: 4px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            display: none; /* 初始隐藏 */
        }

        /* 界面 UI */
        .ui-layer {
            position: absolute;
            text-align: center;
            z-index: 10;
        }

        h1 { margin-bottom: 30px; font-size: 48px; text-shadow: 2px 2px 4px #000; }
        
        button {
            padding: 15px 30px;
            font-size: 24px;
            margin: 0 20px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            transition: transform 0.1s;
            font-weight: bold;
        }

        button:hover { transform: scale(1.1); }
        button:active { transform: scale(0.95); }

        .btn-shen { background-color: #3498db; color: white; }
        .btn-kuang { background-color: #e74c3c; color: white; }
        .btn-restart { background-color: #2ecc71; color: white; margin-top: 20px; }

        #selectionScreen { display: block; }
        #gameOverScreen { display: none; }
        
        .controls-hint {
            margin-top: 10px;
            color: #aaa;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="selectionScreen" class="ui-layer">
        <h1>选择你的角色</h1>
        <button class="btn-shen" onclick="startGame('沈奎')">我是 沈奎</button>
        <button class="btn-kuang" onclick="startGame('狂将')">我是 狂将</button>
        <div class="controls-hint">操作：A/D移动，空格键攻击</div>
    </div>

    <div id="gameOverScreen" class="ui-layer">
        <h1 id="winnerText">胜利!</h1>
        <p id="loserText" style="color:#aaa; font-size: 20px;"></p>
        <button class="btn-restart" onclick="location.reload()">重新开始</button>
    </div>

    <canvas id="gameCanvas" width="800" height="500"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // 游戏状态
        let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER
        let player, enemy;
        let particles = []; // 血液粒子数组

        // 角色类
        class Fighter {
            constructor(name, color, x, isPlayer) {
                this.name = name;
                this.color = color;
                this.x = x;
                this.y = 300; // 地面高度
                this.width = 50;
                this.height = 100;
                this.hp = 100;
                this.speed = 5;
                this.isPlayer = isPlayer;
                this.isAttacking = false;
                this.attackCooldown = 0;
                this.facingRight = x < 400; // 初始朝向
                this.dead = false;
            }

            draw() {
                if (this.dead) return; // 死了就不画了，或者画尸体

                // 绘制身体
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // 绘制眼睛 (区分朝向)
                ctx.fillStyle = 'white';
                let eyeX = this.facingRight ? this.x + 30 : this.x + 10;
                ctx.fillRect(eyeX, this.y + 20, 10, 10);

                // 绘制名字
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.x + 25, this.y - 20);

                // 绘制血条背景
                ctx.fillStyle = '#555';
                ctx.fillRect(this.x - 10, this.y - 40, 70, 10);
                
                // 绘制当前血量
                let hpPercent = Math.max(0, this.hp) / 100;
                ctx.fillStyle = hpPercent > 0.3 ? '#2ecc71' : '#e74c3c';
                ctx.fillRect(this.x - 10, this.y - 40, 70 * hpPercent, 10);

                // 攻击特效 (简单的拳头)
                if (this.isAttacking) {
                    ctx.fillStyle = '#fff';
                    let punchX = this.facingRight ? this.x + this.width : this.x - 30;
                    ctx.fillRect(punchX, this.y + 30, 30, 20);
                }
            }

            update(target) {
                if (this.dead) return;

                // 冷却处理
                if (this.attackCooldown > 0) this.attackCooldown--;
                if (this.attackCooldown < 15) this.isAttacking = false; // 攻击持续时间结束

                // AI 逻辑 (如果是敌人)
                if (!this.isPlayer && !target.dead) {
                    let dist = target.x - this.x;
                    this.facingRight = dist > 0;
                    
                    if (Math.abs(dist) > 60) {
                        // 追逐
                        this.x += dist > 0 ? 3 : -3;
                    } else {
                        // 攻击范围内，随机攻击
                        if (Math.random() < 0.05) this.attack(target);
                    }
                }

                // 边界限制
                if (this.x < 0) this.x = 0;
                if (this.x > canvas.width - this.width) this.x = canvas.width - this.width;
            }

            attack(target) {
                if (this.dead || this.attackCooldown > 0) return;
                
                this.isAttacking = true;
                this.attackCooldown = 30; // 冷却时间

                // 简单的碰撞检测
                let range = 80;
                let dist = Math.abs((this.x + this.width/2) - (target.x + target.width/2));
                
                // 只有面向敌人且距离够近才算打中
                let correctDirection = (this.facingRight && target.x > this.x) || (!this.facingRight && target.x < this.x);

                if (dist < range && correctDirection && !target.dead) {
                    target.takeDamage(10); // 造成伤害
                }
            }

            takeDamage(amount) {
                this.hp -= amount;
                createBlood(this.x + this.width/2, this.y + 30); // 飙血特效

                // 击退效果
                this.x += this.x < 400 ? -20 : 20;

                if (this.hp <= 0) {
                    this.hp = 0;
                    this.die();
                }
            }

            die() {
                this.dead = true;
                createMassiveBlood(this.x + this.width/2, this.y + 50); // 死亡大出血
                endGame(this.isPlayer ? enemy.name : player.name, this.name);
            }
        }

        // 血液粒子类
        class Particle {
            constructor(x, y, isMassive) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 2;
                this.speedX = (Math.random() - 0.5) * 10;
                this.speedY = (Math.random() - 1) * 10;
                this.color = '#aa0000'; // 血红色
                this.life = 100; // 存在时间
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.speedY += 0.5; // 重力
                this.life -= 2;
                
                // 地面碰撞
                if (this.y > 400) {
                    this.y = 400;
                    this.speedY = 0;
                    this.speedX = 0;
                }
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life / 100;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }

        function createBlood(x, y) {
            for(let i=0; i<10; i++) {
                particles.push(new Particle(x, y));
            }
        }

        function createMassiveBlood(x, y) {
            for(let i=0; i<50; i++) {
                particles.push(new Particle(x, y));
            }
        }

        // 键盘输入处理
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (gameState === 'PLAYING' && e.code === 'Space') {
                player.attack(enemy);
            }
        });
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        // 游戏主逻辑
        function startGame(playerName) {
            document.getElementById('selectionScreen').style.display = 'none';
            canvas.style.display = 'block';
            gameState = 'PLAYING';

            // 初始化角色
            if (playerName === '沈奎') {
                player = new Fighter('沈奎', '#3498db', 100, true);
                enemy = new Fighter('狂将', '#e74c3c', 600, false);
            } else {
                player = new Fighter('狂将', '#e74c3c', 600, true);
                enemy = new Fighter('沈奎', '#3498db', 100, false);
                // 修正狂将作为玩家时的初始朝向
                player.facingRight = false;
                enemy.facingRight = true;
            }

            gameLoop();
        }

        function endGame(winnerName, loserName) {
            gameState = 'GAMEOVER';
            setTimeout(() => {
                document.getElementById('gameOverScreen').style.display = 'block';
                document.getElementById('winnerText').innerText = winnerName + " 获胜!";
                document.getElementById('loserText').innerText = loserName + " 被打得头破血流，倒地不起。";
            }, 1000);
        }

        function gameLoop() {
            // 清空画布
            ctx.fillStyle = '#333';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 绘制地面
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 400, canvas.width, 100);

            if (gameState === 'PLAYING' || gameState === 'GAMEOVER') {
                // 玩家移动逻辑
                if (!player.dead) {
                    if (keys['KeyA'] || keys['ArrowLeft']) {
                        player.x -= player.speed;
                        player.facingRight = false;
                    }
                    if (keys['KeyD'] || keys['ArrowRight']) {
                        player.x += player.speed;
                        player.facingRight = true;
                    }
                }

                // 更新实体
                player.update(enemy);
                enemy.update(player);

                // 更新粒子 (血液)
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    particles[i].draw();
                    if (particles[i].life <= 0) particles.splice(i, 1);
                }

                // 绘制角色
                // 确保活着的角色画在上面
                if (player.dead) {
                    player.draw(); // 实际上dead方法里return了，这里主要是为了逻辑顺畅，如果要做尸体效果可以在这里
                    enemy.draw();
                } else {
                    enemy.draw();
                    player.draw();
                }
            }

            if (gameState !== 'MENU') {
                requestAnimationFrame(gameLoop);
            }
        }

    </script>
</body>
</html>